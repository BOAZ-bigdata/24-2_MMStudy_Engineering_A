# 2주차 정리
- 목차
  - 사용자 수에 따른 규모 확장성
  - 개략적인 규모 추정
  - 시스템 설계 면접 공략법

# 사용자 수에 따른 규모 확장성
- 간단한 시스템 구성 (단일 서버)
  - 웹,앱,DB,캐시 등이 모두 하나의 서버에서 실행됨
  <img width="400" alt="그림1-1" src="https://github.com/user-attachments/assets/4cf9d293-df0b-4b05-8dea-ee7d325aa6f3">

  - 도메인 이름을 가진 사용자는 DNS를 통해 IP 주소를 반환 받게됨
  - IP 주소를 통해 HTTP 요청이 전달 되고, 웹 서버는 HTML이나 JSON 형태의 응답을 반환함

  <img width="550" alt="스크린샷 2024-07-24 오전 12 26 55" src="https://github.com/user-attachments/assets/cc4263f8-9b87-4818-b665-8dcd08046844">
 
## 데이터베이스
- 역할에 따라 여러 서버가 필요
  - 트래픽 처리 서버 & 데이터베이스 서버 (책에서는 독립성을 강조함)
<img width="400" alt="스크린샷 2024-07-22 오후 6 27 55" src="https://github.com/user-attachments/assets/8ecdcfa9-dbb1-4684-961f-518b997d0b7b">

- 관계형 DB (RDBMS, SQL) & 비 관계형 DB (NoSQL)
  - 관계형 DB :
      - 테이블,열,행 사용한것
      - MySQL, PostgreSQL ...
  - 비 관계형 DB :
      - key-value store, graph store, column store, document store
      -  Redis(key-value), MongoDB(document), Cassandra(column) ...
1. 아주 낮은 응답 지연시간이 요구됨 : NoSQL은 고성능과 낮은 지연시간을 제공하도록 설계됨
2. 비정형 관계
3. 데이터를 직렬화하거나 역직렬화 : 데이터를 연속적인 바이트 단위로 변환 후 저장하거나 전송하는 과정을 지원해줌
4. 아주 많은 양의 데이터를 저장할때 : 수평적 확장이 가능하기 때문

## 수직적 규모 확장(scale up) vs 수평적 규모 확장(scale out)
- scale up : 컴퓨터 자원을 추가하는 거 (cpu,ram 추가...)
  - 확장에 물리적 한계가 있음
  - 장애에 대한 자동복구, 다중화 방안을 제시하지 못함
- scale out : 여러 서버를 추가하는 거
  - 대규모 애플리케이션에 더 적합
## Load Balancer
<img width="400" alt="스크린샷 2024-07-22 오후 7 08 00" src="https://github.com/user-attachments/assets/83cf1e3e-5e78-4106-8699-5ab745a7136e">

- 웹 서버의 트래픽 부하를 고르게 분산하는 역할을 함
- 사용자는 로드밸런서에의 공개IP 주소로 접속을 함 (직접 웹 서버에 접속X)
- 로드밸런서는 웹 서버와 사설IP(같은 네트워크에 속한 서버 사이에 쓰이는 거)를 통해 접속함 (보안성 높아짐)

## 데이터베이스 다중화
<img width="400" alt="스크린샷 2024-07-22 오후 7 16 28" src="https://github.com/user-attachments/assets/0e0bf37d-2565-40d9-b5bf-47c3fdf98e8d">

- 데이터 원본은 주서버, 사본은 부 서버에 저장
- 쓰기 연산은 마스터에서만 지원
- 부 데이터베이스는 읽기 연산만 가능
- 쓰기와 읽기를 분리하고, 읽기 데이터베이스 서버를 분산하면 쿼리의 수가 늘어나 성능이 좋아짐
- 물리적으로 다중화를 했기에 안정성과 가용성을 가짐
<img width="500" alt="스크린샷 2024-07-22 오후 7 36 26" src="https://github.com/user-attachments/assets/ec4866f7-f115-4d53-8dfc-07401e77297a">

## 캐시
- 빠른 요청 처리
- DB 부하를 줄여, 애플리케이션의 성능 향상
- 캐시 계층을 활용
<img width="400" alt="스크린샷 2024-07-22 오후 8 18 20" src="https://github.com/user-attachments/assets/de23b486-9b00-4b33-a32f-1900b0036b0d">

- 캐시 사용 시 고려할점
  - 갱신은 자주 일어나지 않지만, 참조가 빈번하게 일어날때
  - 어느정도 보관할지..
  - 일관성
  - 장애 대응 : 단일 장애지점 (캐시 서버를 분산해서...)
  - 데이터 방출 정책 : LRU(빈도가 가장 낮은 데이터 내보냄), FIFO 등...
    
## CDN (콘텐츠 전송 네트워크)
- 지리적으로 분산된 서버의 네트워크 (정적 콘텐츠를 전송하는데 쓰임) //동적인 콘텐츠는 추후에...
- 이미지, 동영상, css, js 파일 등을 캐시할 수 있음 
<img width="600" alt="스크린샷 2024-07-22 오후 8 30 09" src="https://github.com/user-attachments/assets/5d3023f2-c6cc-4f42-b0a7-d6d17c63f626">

- 고려할 사항
  - 비용 : 주로 제3 사업자에 의해 운영되므로.. 비용 절감이 필요
  - 적절한 만료 시한 설정 : 콘텐츠에 적절한 만료 시점을 정해야함
  - 장애 대처 : 장애가 발생했을때, 대응책이 필요
<img width="500" alt="스크린샷 2024-07-22 오후 8 37 44" src="https://github.com/user-attachments/assets/9f00f614-8661-4ce6-9f38-8555a45e5f98">

- 정적 콘텐츠는 웹 서버를 통해 서비스하지 않고, CDN을 통해 제공함
- 캐시가 DB 부하를 줄여줌

## 무상태 웹 계층
- 웹 계층을 수평적으로 확장해야 함
- 상태 정보(사용자 세션 데이터...)를 DB에 보관하여, 웹 계층에서 제거함
- 이렇게 구성하는 웹 계층을 '무상태 웹 계층' 이라고 부름

- 상태 정보 의존적 vs 무상태
  
  - 상태 정보 의존적 
    - 상태 정보를 유지하기 위해 요청들 사이 공유되도록 설정되어 있음
    - 이때 요청은 항상 같은 서버로 전송되어야함
    - 로드밸런서가 '고정 세션'을 통해 기능을 제공하지만, 부담이 발생함
  
    
    <img width="500" alt="스크린샷 2024-07-22 오후 9 08 05" src="https://github.com/user-attachments/assets/5c7822c8-fd4b-436d-be98-b98b643170a0">
    
  - 무상태 아키텍처
    - 사용자 요청 HTTP이 어떤 웹 서버로도 전달될 수 있음
    - 공유 저장소와 물리적으로 분리됨
    - 확장성에 좋음
    
    <img width="500" alt="스크린샷 2024-07-22 오후 9 09 40" src="https://github.com/user-attachments/assets/6869dc5c-9d81-4e86-b385-c09c4ac14594">

  - 무상태 웹 계층을 바탕으로한 거
  - 
    <img width="500" alt="스크린샷 2024-07-22 오후 9 17 08" src="https://github.com/user-attachments/assets/9b1dac6b-6aa6-48d3-89dc-50a9d4daedd2">

## 데이터센터
- 지러적 라우팅(geo-routing) : 사용자는 가장 가까운 데이터 센터로 안내함
- geoDNS : 사용자의 위치에 따라 도메인 이름을 어떤 IP주소로 변환할지 결정해주는 서비스 (어떤 센터로 보낼지 결정하는거...)
- 해결해야할 문제점 :
  - 트래픽 우회 : 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야함
  - 데이터 동기화 : 데이터를 여러 데이터센터에 걸쳐 다중화 시켜야함

## 메시지 큐
- 메시지 큐 : 메시지의 무손실을 보장하는 비동기 통신 컴포넌트
  - 무손실(durability) : 메시지 큐에 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성
  - 비동기 통신 : 요청을 보내고, 응답을 기다리지 않고 다른 작업을 수행함  

<img width="500" alt="스크린샷 2024-07-22 오후 9 42 04" src="https://github.com/user-attachments/assets/4432041f-03ea-476e-9193-168ff0110e03">

- 장점
  - 서버 간 결합이 느슨해져, 규모 확장성이 보장되어야 애플리케이션에 좋음
  - 비동기 통신의 장점을 활용할 수 있음
<img width="500" alt="스크린샷 2024-07-22 오후 9 47 01" src="https://github.com/user-attachments/assets/e8f5a2b8-0a55-4f2d-a9d2-0e1a7f16fadc">

- 생산자와 소비자가 독립적으로 작업할 수 있는 환경을 구성해줌

## 로그, 메트릭, 자동화
- 로그 : 모니터링하기 위해서 필요..
- 매트릭 :
  - 호스트 단위 매트릭 : cpu, 메모리, 디스크 I/O 등...
  - 종합 매트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능 ...
  - 핵심 비즈니스 매트릭 : 일별 능동 사용자, 수익, 재방문 ...
- 자동화 : 개발 생산성 크게 향상

<img width="550" alt="스크린샷 2024-07-22 오후 10 03 42" src="https://github.com/user-attachments/assets/d04faef3-d2d4-4f4a-a172-1feb9634507d">

## 데이터베이스의 규모 확장
- 수직적 확장 vs 수평적 확장

- 데이터베이스의 수평적 확장은 샤딩(sharding)이라고 부름
  - 샤딩은 '샤드'라고 불리는 데이터베이스의 집합체
  - 모든 샤드는 같은 스키마를 쓰지만, 중복되는 데이터가 없음
<img width="450" alt="스크린샷 2024-07-22 오후 10 08 03" src="https://github.com/user-attachments/assets/a1eeed2d-5948-4e75-82b6-38db0daed947">

- 샤딩 전략에서 샤딩 키(파티션 키)를 고려하는게 가장 중요함
  - 데이터를 고르게 분할 할 수 있는지
  - 데이터 조회나 변경을 효율적으로 할 수 있는지

- 샤딩 도입시 문제점
  - resharding :
    - 데이터가 너무 많아서, 하나의 샤드로는 감당 불가
    - 데이터 분포가 균등하지 못 하여, 공간 소모가 빨리 될때
  - celebrity(유명인사 문제) : 특정 샤드에 쿼리가 집중되어, 과부하 발생 문제
  - join & de-normalization : 여러 샤드가 존재하면, 데이터 조인이 힘들어짐
      - 데이터를 비정규화하여 하나의 테이블에서 쿼리가 수행되도록 해야 함

<img width="600" alt="스크린샷 2024-07-22 오후 10 20 45" src="https://github.com/user-attachments/assets/de4a2642-1884-430e-90f3-ce8afdfede80">

- SQL 에서 요구되지 않는 기능은 NoSQL로 이전하도록 구현...


# 개략적인 규모 추정
- 규모 확장성을 표현하는 데 필요한 기본기를 알 필요가 있음

## 2의 제곱수 
<img width="450" alt="스크린샷 2024-07-22 오후 10 25 16" src="https://github.com/user-attachments/assets/ae0a8f4d-38ad-419c-8841-7b6895587d0d">

- 1byte = 8bit

## 응답지연 값
- 컴퓨터 연산들의 처리 속도를 짐작할 수 있음
<img width="450" alt="스크린샷 2024-07-22 오후 10 27 20" src="https://github.com/user-attachments/assets/504f9d04-cd36-4780-a05d-921ce1ecda30">

-요약
  - 메모리는 빠르지만, 디스크는 느림
  - 디스크 탐색은 피하기
  - 단순한 압축 알고리즘은 빠름
  - 데이터를 인터넷으로 전송하기 전에 압축하기
  - 데이터센터들 간에 데이터를 주고 받는데는 시간이 걸림

## 가용성에 관계된 수치들
- 고가용성 : 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 말함
- 대부분의 서비스들은 99% ~ 100% 사이의 값을 가짐
- SLA : 서비스 사업자와 고객 사이에 맺어진 합의로, 서비스의 가용시간이 공식적으로 기술되어 있음
- 가용시간은 관습적으로 9를 사용하며, 9가 많을 수록 가용성이 좋음
<img width="500" alt="스크린샷 2024-07-22 오후 10 30 56" src="https://github.com/user-attachments/assets/8ab93b48-48c1-4f52-92ee-1180a45b0c2f">

  - 팁
    - 근사치 활용해 계산
    - 가정 적어놓기
    - 단위 붙이기
    

# 시스템 설계 면접 공략법
- 시스템 설계 면접은 모호한 문제를 동료들과 협력하여 해결하는 과정에 대한 시뮬레이션

## 효과적인 면접은 위한 4단계 접근법
1. 문제 이해 및 설계 범위 확정
  - 답부터 들이지 말고, 깊이 생각하고 질문을 통해 면접관들에게 정보를 얻어라
  - 질문을 통해 요구사항 파악하기
2. 개략적인 설계안 제시 및 동의 구하기
  - 면접관과 협력하기
  - 질문을 통해 청사진 설계하기
3. 상세 설계
  - 상세 설계할거 집중하기 (설계 대상 컴포넌트 우선순위 정하기)
  - 불필요한거 시간쓰지 말기
4. 마무리
  - 후속 질문 대비
    - 시스템 병목구간, 개선 가능 지점 파악
    - 설계에 대한 요약
    - 이슈 논의 ...
   
  

