# 카프카 컨슈머 : 카프카에서 데이터 읽기
- 카프카에서 데이터를 읽는 애플리케이션은 토픽을 구독하고, 구독한 토픽들로부터 메시지 받기 위해 KafkaConsumer를 사용함

## 카프카 컨슈머: 개념

### 컨슈머와 컨슈머 그룹
- 토픽으로부터 데이터를 읽어 오는 작업을 확장할 수 있어야 함
- 여러 개의 컨슈머가 같은 토픽으로부터 데이터를 분할해서 읽어올 수 있어야 함
- 동일한 컨슈머 그룹에 속한 여러 컨슈머는 동일한 토픽을 구독하였지만, 서로 다른 파티션의 메시지를 받음
<img width="759" alt="스크린샷 2024-08-07 오전 2 33 02" src="https://github.com/user-attachments/assets/e3c0e193-9985-4ef7-8c05-58c2b02fab59">

- 컨슈머 그룹에 컨슈머를 추가하는 것은 카프카 톡픽에서 읽어오는 데이터 양을 확장하는 주된 방법임
- 그러나 토픽에 설정된 파티션 수 이상으로 컨슈머를 추가하는 것은 아무 의미 없음
- 카프카는 성능 저하 없이 확장이 가능함
<img width="864" alt="스크린샷 2024-08-07 오전 2 37 05" src="https://github.com/user-attachments/assets/52058e71-fef3-4831-bde8-e5660aedc14c">

- 추가된 컨슈머 그룹은 기존 컨슈머 그룹의 영향을 받지 않고, 독립적으로 수행됨

### 컨슈머 그룹과 파티션 리밸런스
- 컨슈머 그룹에 컨슈머가 추가되거나, 삭제되면 재할당을 통해 밸런스를 맞춤
- 조급한 리밸런스
  - 모든 컨슈머가 자신에게 할당된 파티션을 포기하고,
  - 파티션을 포기한 컨슈머 모두가 다시 그룹에 참여해야, 새로운 파티션을 받고 읽기 작업을 할 수 있음
<img width="973" alt="스크린샷 2024-08-07 오전 2 44 36" src="https://github.com/user-attachments/assets/f267a43d-6a58-4d67-8596-e804662b4f97">

- 조급한 리밸런스는 모든 파티션 할당을 해제한 뒤 읽기 작업을 정지시키고, 파티션을 다시 할당함

- 협력적 리밸런스
  - 한 컨슈머에게 할당된 파티션만을 다른 컨슈머에게 재할당 하는거
  - 2개 이상의 단계를 거침
    1. 리더가 재할당할것이라 통보 -> 컨슈머들은 작업 멈추고, 파티션에 대한 소유권 포기
    2. 소유권 포기한 파티션에 리더가 파티션을 재할당함
    3. 안정될때까지 재반복함...
    4. 조급한 리밸런스에서 발생하는 전체 작업이 중단되는 사태는 발생하지 않음..
<img width="973" alt="스크린샷 2024-08-07 오전 2 44 36" src="https://github.com/user-attachments/assets/f267a43d-6a58-4d67-8596-e804662b4f97">

  - 컨슈머는 해당 컨슈머 그룹의 그룹 코디네이터 역할을 지정받은 카프카 브로커에 하트비트를 전송함으로써 맴버쉽과 할당된 파티션에 대한 소유권을 유지함
  - 하트비트 -> 주기적으로 파악함
- 정적 그룹 맴버쉽
  - 컨슈머가 갖는 컨슈머 그룹의 맴버 자격은 일시적임
  - 컨슈머 그룹 나가면, 끝남.. 다시 들어오면 재할당 받고...
  - 컨슈머에 고유한 group.instance.id값(정적으로 참여하게 해줌)을 잡아주지 않으면 유효함 -> 리밸런스를 발생시키지 않음
  - 정적 그룹 맴버쉽은 애플리케이션이 각 컨슈머에 할당된 파티션의 내용물을 사용해서 로컬이나 캐시를 유지할때 편리함
  - 반복 작업에 효율적
  - 재할당되지 않기에, 잃어버린 파티션들로부터 메시지를 읽어오지 않음, 나중에 컨슈머가 다시 와서 읽으면 순서는 맨 뒤로 이동할거임...
  - 컨슈머 그룹 정적 맴버가 종료됨은 session.timout.ms 설정에 달려있음
 
  ## 카프카 컨슈머 생성하기
  - 카프카 레코드를 읽어오기 위해서는 카프카 컨슈머 인스턴스를 생성해야함
  - 자바 properties 객체를 생성해서 컨슈머에게 넘겨주면 됨
  - kafkaconsumer instance가 속하는 컨슈머 그룹을 지정하는 group.id 속성도 사용됨
    p.91코드 참고

## 토픽 구독하기
- 컨슈머를 생성 후 1개 이상의 토픽을 구독해야함, subscribe() 메소드를 활용

## 폴링 루프
- 컨슈머 API 핵심은 서버에 추가 데이터가 들어왔는지 폴링하는 단순한 루프임
- 컨슈머는 카프카를 계속해서 폴링하지 않으면 죽은 것으로 간주되어, 이 컨슈머가 읽고 있던 파티션들은 그룹내의 다른 컨슈머에게 넘겨짐
- poll()에 전달하는 매개변수는 값이 0이거나 버퍼 안에 이미 레코드가 준비되어있으면 즉시 리턴함(list형태), 아니면 지정된 초만큼 기다림
- 데이터를 가져오는거 이외에도 컨슈머에서 처음으로 poll()을 호출하면 컨슈머 GroupCordinator를 찾아서 그룹에 참여하고, 파티션을 할당 받음
- 리밸런스 역시 연관된 콜백들과 함깨 여기서 처리함

## 스레드 안전성
- 하나의 스레드에서 동일한 그룹 내에 여러 개의 컨슈머를 생성할 수 없음
- 같은 컨슈머를 다수의 스레드가 안전하게 사용할 수도 없음
- 스레드당 하나의 컨슈머가 원칙
- 여러개할려면 스레드를 여러개 뛰워야함
## 컨슈머 설정하기
- p.94~p.102 한번 읽어보기... 정리하는것보다 그냥 보는게 좋은듯..

## 오프셋과 커밋
- 우리가 poll()을 호출할 때마다 카프카에 쓰인 메시지중 아직 컨슈머가 읽지 않은 레코드는 리턴됨
- 이를 통해 컨슈머가 어떤 레코드를 읽었는지 알 수 있음
- 컨슈머가 카프카를 사용해서 각 파티션에서의 위치를 추적할 수 있게 함
- 카프카에서 파티션 현재 위치를 업데이트하는 작업을 '오프셋 커밋'이라고 부름
- 카프카는 레코드를 개별적으로 커밋하지 않고, 컨슈머가 파티션에 성공적으로 처리해 낸 마지막 메시지를 커밋해서, 앞에 메시지들 모두 성공했다고 처리함
- __consumer_offsets 특수 톡픽에서 각 파티션별로 커밋된 오프셋을 업데이트하도록 하는 메시지를 보냄으로써 오프셋을 커밋함
- 컨슈머가 크래시되거나, 새로운 컨슈머가 추가되면, 리밸런스가 발생함
  - 이후 컨슈머는 리밸런스 이전에 처리하고 있던 다른 파티션들을 할당 받을 수 있음
  - 이때 어디서부터 작업을 해야할지 알기 위해 마지막으로 커밋된 메시지를 읽어와서 거기서부터 작업 시작함
## 커밋을 활용하는 방안에 대해 읽어보면 될듯
p.103 ~p.112

## 폴링 루프를 벗어나는 방법
- 즉시 탈출을 원하면 다른 스레드에서 consumer.wakeup()을 호출하면됨
  - 다른 스레드에서 호출해줄 때만 안전하게 작동하는 유일한 컨슈머 메서드임
- 메인 스레드에서 컨슈머가 돌고 있으면 ShutdownHook을 사용하면 됨
- consumer.close()
  - 닫으면, 오프셋을 커밋하고 그룹 코디네이터에게 컨슈머가 그룹을 떠난다는 메시지를 전송함
  - 코디네이터는 즉시 리밸런싱을 시킴
## 디시리얼라이저
- 컨슈머가 카프카로부터 받은 바이트 배열 메시지를 자바 객채로 변환하기 위해 필요함
- 커스텀해서도 쓸 수 있음

## 독립 실행 컨슈머
- 그룹이 아닌 하나의 컨슈머가 토픽의 모든 파티션으로부터 모든 데이터를 읽어야할때가 있음
- 이때는 그룹, 리밸런스 기능 필요하지 않고, 컨슈머에게 특정 토픽과 파티션 할당하고, 메시지를 읽어서 처리하고, 오프셋을 커밋하면됨
- 리밸런싱을 할 수 없고, 직접 파티션을 찾아야 한다는 단점이 있긴함

