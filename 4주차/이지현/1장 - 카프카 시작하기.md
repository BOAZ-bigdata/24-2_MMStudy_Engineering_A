# 1장 카프카 시작하기
카프카가 필요한 이유는 -> 데이터는 중요한 정보를 담고 있기 때문에 데이터를 생성된 곳에서 분석할 수있는 곳으로 옮겨야하고 , 이 데이터를 어떻게 이동시키느냐의 문제가 데이터 그 자체 만으로 매우 중요함.

핵심 키워드 : 발행/구독 메시지 | 메시지 | 프로듀서/컨슈머 | 

## 1.1 발행/구독 메시지 전달
발행 구독 메시지 전달이란 무엇일까?

### 발행자(=전송자, 프로듀서, 작성자): 데이터를 생성(새로운 메시지)
-> 데이터를 생성한다는 의미는?

데이터 생성은 특정 애플리케이션이나 시스템에서 발생하는 이벤트나 정보를 의미

### 구독자(=수신자, 컨슈머, 독자): 메시지를 읽어감.

-> 분류된 메시지를 구독한다.

### 초기 발행/구독 시스템

가운데 간단한 메시지 큐나 프로세스 간 통신 채널을 놓아서 연결시켰다.
하지만 애플리케이션이 확장될 수록 서버를 추가해야하고 연결을 추적하는 것이 힘들어진다. 

## 1.2 카프카 입문
### 핵심 키워드: 메시지, 배치, 토픽, 파티션, 스트림, 브로커, 클러스터

카프카는 중복을 없애고, 비즈니스가 확장됨에 따라 확장되는 일반화된 유형의 데이터를 발행하고 구독할 수 있는 `중앙 집중화된 시스템`을 위해 개발됐다.
카프카에 저장된 데이터는 순서를 유지한 채로 지속성 있게 보관되며 결정적으로 읽을 수 있다

### 메시지와 배치
카프카에서 데이터의 기본 단위가 `메시지`다.
카프카의 입장에서는 메시지는 단순히 바이트의 배열이기에 여기에 포함된 데이터에는 특정한 형식이나 의미가 없다. 메시지 안에는 키 라 불리는 메타데이터가 포함될 수 있다. 이 키는 메시지를 저장할 파티션을 결정하기 위해 사용된다.

효율성을 위해 `배치 단위`로 베시지를 저장한다.
배치는 같은 토픽의 파티션에 쓰여지는 메시지들의 집합일 뿐이다.
배치 단위로 모아서 쓰면 막대한 오버헤드를 줄일 수 있다.

### 스키마
메시지는 단순한 배이트의 배열이지만 내용을 이해하기 쉽도록 일정한 구조(스키마)를 부여 하는 것이 권장된다. 카프카에서는 아파치 Avro 를 사용한다. 아브로는 직렬화 형식을 제공하고 메시지 본체와 스키마를 분리하기 떄문에 스키마가 변경되더라도 코드를 생성할 필요 없다.

### 토픽과 파티션 그리고 스트림
카프카에 저장되는 메시지는 `토픽` 단위로 분류된다. (데이터베이스 테이블이나 파일시스템의 폴더와 비슷한 개념)

토픽은 다시 여러 개의 파티션으로 나뉘어진다. 파티션은 하나의 로그에 해당되어 쓰여질 때는 추가만 가능한 형태로 쓰이고 읽을 떄는 맨 앞부터 순서대로 읽힌다. 

여러개의 파티션 내에서의 순서는 보장되지 않아도 단일 파티션 안에서는 순서가ㅏ 보장된다. 
파티션은 카프카가 데이터 중복과 확장성을 제공하는 방법이기도 하다. 

스트림은 하나의 토픽에 저장된 데이터로 간주되고 프로듀서로부터 컨슈머로의 하나의 데이터 흐름을 나타낸다. 메시지를 실시간으로 처리하는 것처럼 스트림 처리에 대한 논의를 진행할 때 가장 일반적. 

### 프로듀서와 컨슈머
프로듀서: 새로운 메시지를 생성한다. 메시지는 특정한 토픽에 쓰여지고 최대한 파티션들 사이에 고르게 쓰도록한다. 하지만 경우에 따라 특정한 파티션을 지정해서 메시지를 쓰기도 한다. 

컨슈머: 메시지를 읽는다. 메시지의 오프셋을 기록함으로써 어디까지 읽었는지를 유지한다. 주어진 파티션의 각 메시지는 고유한 오프셋을 가진다.

컨슈머 그룹: 컨슈머 중 하나에 장애가 발생하더라도, 그룹 안의 다른 컨슈머들이 장애가 발생한 컨슈머가 읽고 있던 파티션을 재할당 받은 뒤 이어서 데이터를 읽어올 수 있다.

### 브로커와 클러스터
브로커: 하나의 카프카 서버를 브로커라고 부른다

브로커는 프로듀서보부터 메시지를 전달받아 오프셋을 할당한 뒤 디스크 저장소에 쓴다. 

카프카 브로커는 클러스터의 일부로서 작동하도록 설계되었다. 하나의 클러스터 안에 여러 개의 브로커 포함 가능하고, 그 중 하나가 클러스터 컨트롤러의 역할을 한다.
컨트롤러는 파티션을 브로커에 할당해주거나 모니터링하는 등 관리 기능하고, 
파티션은 클러스터 안의 브로커 중 하나가 담당하고 그 브로커를 파티션 리더라고 부르고 복제된 파티션이 여러 브로커에 할당될 수 있는 데 이것들을 파티션의 팔로워라고 부른다.

    - 즉, 하나의 카프카 클러스터 안에 브로커들이 여러개 있고 그 중 하나는 클러스터 컨트롤러 역할, 그 중 다른 하나는 파티션의 역할을 하여 파티션 리더라고 불린다.

### 다중 클러스터
카프카가 점점 확장됨에 따라 다수의 클러스터를 운용하는 것이 더 나은 경우가 많다. 다수의 데이터 센터에서 운영될 떄 데이터 센터 간에 메시지를 복제할 필요가 있는데,카프카 클러스터의 복제 메커니즘은 하나의 클러스터 안에서만 작동하도록 설계되었다.

미러메이커라는 툴을 포함하여 데이터를 다른 클러스터로 복제시킨다.

## 1.3 왜 카프카야?
### 다중 프로듀서, 다중 컨슈머, 디스크 기반 보존, 확장성, 고성능, 플랫폼 기능

### 다중 프로듀서
: 여러 프로듀서를 처리할 수 있다.

많은 프론트엔드 시스템으로부터 데이터를 수집하고 일관성을 유지하는ㄷ ㅔ적격이다,

### 다중 컨슈머
: 많은 컨슈머가 상호 간섭 없이 어떠한 메시지 스트림도 읽을 수 있다.

이것이 하나의 메시지를 하나의 클라이언트에서만 소비할 수 있게 되어 있는 많은 큐 시스템과의 결정적 차이다.

### 디스크 기반 보존
: 메시지를 지속성 있게 저장하여 컨슈머들이 항상 실시간으로 데이터를 읽어올 필요가 없다. 디스크에 쓰여진 뒤 보유 규칙과 함께 저장되어 유실 없이 데이터 처리 가능

## 1.4 데이터 생태계
아파치 카프카는 데이터 생태계에 있어서 순환 시스템을 제공한다. 모든 클라이언트에 대해 일관된 인터페이스를 제공하면서 인프라스트럭처 요소들 사이에 메시지를 전달 한다.

### 이용 사례
- 활동 추적
하나 이상의 토픽으로 메시지가 발행되어 백엔드에서 작동 중인 애플리케이션에 전달된다.
- 메시지 교환
- 지표 및 로그 수집
- 커밋 로그
- 스트림 처리

## 1.5 카프카의 기원
링크드인 내부에서의 데이터 파이프라인 문제를 해결하기 위해 개발되었다. 
그동안의 시스템은 간단한 작업조차 사람이 만져줘야하고 지표 이름까지 달라져서 일관성이 없었다. 

즉, 모니터링 시스템과 사용자 활동 정보를 추적하기 위한 시스템으르 위해 개발되었다. 