# 카프카 컨슈머 : 카프카에서 데이터 읽기

## 컨슈머와 컨슈머 그룹

- 여러 개의 프로듀서가 동일한 토픽에 메시지를 쓰듯, 여러 개의 컨슈머가 같은 토픽으로부터 데이터를 분할해서 읽어올 수 있어야 함
- 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우, 각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메시지를 받음
- 컨슈머 그룹에 컨슈머 추가하는 것
	- 카프카 토픽에서 읽어오는 데이터 양을 확장하는 주된 방법

## 컨슈머 그룹과 파티션 리밸런스

- 컨슈머 그룹에 속한 컨슈머들은 구독하는 토픽의 파티션들에 대한 소유권 공유
- 새로운 컨슈머 컨슈머 그룹에 추가
	- 이전에 다른 컨슈머가 읽고 있던 파티션으로부터 메시지 읽음
	- 컨슈머의 종료, 충돌 시에도 마찬가지
> 리밸런스[rebalance] : 컨슈머에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업
> - 고가용성과 규모 가변성 제공

- 리밸런스
	- 조급한 리밸런스 [eager rebalance]
		- 추후 삭제될 예정
		- 모든 컨슈머는 읽기 작엄 멈춤, 할당된 모든 파티션에 대한 소유권 포기, 컨슈머 그룹에 다시 참여
			- 완전히 새로운 파티션 할당을 전달받음
		- 짧은 시간 동안 작업은 멈춤
	- 협력적 리밸런스 [cooperative rebalance] *OR* 점진적 리밸런스 [incremental rebalance]
		- 기본값
		- 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에 할당
			- 다른 컨슈머들은 하던 일 계속 함

> - 컨슈머는 해당 컨슈머 그룹의 `그룹 코디네이터` 역할의 카프카 브로커에 `하트비트` 전송
> 	- 일정 시간 하트비트 전송 X
> 		- 코디네이터는 해당 컨슈머가 죽었다고 간주, 리밸런스 실행

### 정적 그룹 멤버십

- 컨슈머에 고유한 `group.instance.id` 값을 잡아 두면 해당 컨슈머 그룹의 정적인 멤버가 됨
	- 세션 타임아웃이 경과될 때까지 그룹 멤버로 남아 있음
	- 다시 그룹에 조인 시, 예전에 할당받았던 파티션들을 그대로 할당받음
	- 애플리케이션이 각 컨슈머에 할당된 파티션의 내용물을 사용해서 로컬 상태나 캐시를 유지해야 할 때 용이

## 토픽 구독

- 컨슈머를 생성하고 나서는 1개 이상의 토픽을 구독해야 함
> `consumer.subscribe(Collections.singletonList("customerCountries"));`

## 폴링 루프

- 컨슈머 API의 핵심
- 서버에 추가 데이터가 들어왔는지 폴링하는 루프

---

## 오프셋과 커밋

- 오프셋 커밋
	- 파티션에서의 현재 위치를 업데이트하는 작업
	- 카프카는, 파티션에서 성공적으로 처리해 낸 마지막 메시지를 커밋함으로써 그 앞의 모든 메시지들도 성공적으로 처리되었음을 암묵적으로 나타냄

### 자동 커밋

- `enable.auto.commit`을 `true`로 설정하면 컨슈머는 5초에 한 번`poll()`을 통해 받은 메시지 중 마지막 메시지의 오프셋을 커밋

### 현재 오프셋 커밋

- 오프셋이 커밋되는 시각 제어
- 메시지 유실 가능성 제거
- 리밸런스 발생시 중복되는 메시지 수 줄이기

### 비동기적 커밋

- 수동 커밋의 단점
	- 브로커가 커밋 요청에 응답할 때까지 애플리케이션이 블록됨
		- 애플리케이션의 처리량 제한
		- 덜 자주 커밋할 경우
			- 처리량은 올라가지만 리밸런스에 의해 발생하는 잠재적인 중복 메시지는 늘어남
- 브로커가 커밋에 응답할 때까지 기다리는 대신 요청만 보내고 처리르 계속함

### 동기적 커밋 / 비동기적 커밋 함께 사용

- 재시도 없는 커밋이 실패해도 큰 문제는 아님
	- 일시적인 문제라면 뒤이은 커밋이 성공할 것이기 때문
- 컨슈머를 닫기 전 OR 리밸런스 전 마지막 커밋이라면 성공 여부를 추가로 확인할 필요가 있음
	- 종료 직전에 `commitAsync()`와 `commitSync()`를 함께 사용

---

## 리밸런스 리스너

- 컨슈머는 종료하기 전 또는 리밸런싱이 시작되기 전에 정리 작업을 해야 함
- 컨슈머에 할당된 파티션이 해제될 것이라면, 해당 파티션에서 마지막으로 처리한 이벤트의 오프셋을 커밋해야 함

## 디시리얼라이저 [deserializer]

- 카프카 컨슈머가 카프카로부터 받은 바이트 배열을 자바 객체로 변환하기 위해 필요
- 기본값: `StringDeserializer`

---

## 독립 실행 컨슈머 [Standalone Consumer]

> 컨슈머 그룹 없이 컨슈머를 사용해야 하는 이유, 방법


- 하나의 컨슈머가 토픽의 모든 파티션으로부터 모든 데이터를 읽어야 하는 경우
- 토픽의 특정 파티션으로부터 데이터를 읽어와야 할 경우
    -> 컨슈머 그룹이나 리밸런스 기능은 필요 없음
