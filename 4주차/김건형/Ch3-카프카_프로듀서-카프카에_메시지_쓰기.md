# 카프카 프로듀서: 카프카에 메시지 쓰기

## 프로듀서 개요

- 서로 다른 요구 조건은 카프카에 메시지를 쓰기 위해 `프로듀서 API`를 사용하는 방식과 설정에 영향을 미침

1. `ProducerRecord` 객체 생성
	- 토픽, 밸류 지정은 필수
	- 키, 파티션 지정은 선택
2. `ProducerRecord` 를 전송하는 API 호출 시
	- 프로듀서는 키와 값 객체가 네트워크 상에서 전송될 수 있도록 직렬화 하여 바이트 배열로 변환
	- 파티션을 명시적으로 지정하지 않았을 시 해당 데이터 파티셔너에게 보냄
		- 파티셔너 : 파티션 결정 (기준: `ProducerRecord` 객체의 키의 값)
		- 파티션 결정 -> 메시지 전송될 토픽, 파티션 확정
3.  프로듀서는 이 레코드를 같은 토픽 파티션으로 전송될 레코드들을 모은 `레코드 배치`에 추가
	- 별도의 스레드가 이 레코드 배치를 적절한 카프카 브로커에 전송
4. 브로커가 메시지를 받았을 때
	- 성공 : 토픽, 파티션, 해당 파티션 안에서의 레코드의 오프셋을 담은 `RecordMetadata`객체 리턴
	- 실패: 에러 리턴
		- 프로듀서가 에런 수신 시, 메시지 쓰기 포기, 재전송 시도 가능

## 카프카 프로듀서 생성

### 필수 속성값

- bootstrap.servers
	- 카프카 클러스터와 첫 연결을 생성하기 위해 프로듀서가 사용할 브로커의 `host:port` 목록
	- 최소 2개 이상 지정 권장
- key.serializer
	- 카프카에 쓸 레코드의 키의 값을 직렬화하기 위해 사용하는 시리얼라이저 클래스 이름
- value.serializer
	- 카프카에 쓸 레코드의 밸류값을 직렬화하기 위해 사용하는 시리얼라이저 클래스 이름

### 메시지 전송 방법

- Fire and Forget
	- 메시지를 서버에 전송만 하고 성공/실패 여부는 신경 X
- Synchronous Send
- Asynchronous Send

### 프로듀서 설정값

- client.id
	- 프로듀서와 그것을 사용하는 애플리케이션을 구분하기 위한 논리적 식별자
	- 임의의 문자열
	- 브로커가 프로듀서가 보낸 메시지를 서로 구분하기 위해 사용
- acks
	- 프로듀서가 임의의 쓰기 작업이 성공했다고 판별하기 위해 얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는지 결정
	- 0일 때
		- 프로듀서는 메시지가 성공적으로 전달되었다고 간주, 브로커의 응답 기다리지 않음
		- 브로커가 못 받았을 경우, 그 상황에 대해 알지 못함. 그대로 유실
	- 1일 때
		- 프로듀서는 리더 레플리카가 메시지를 받는 순간 브로커로부터 성공했다는 응답을 받음
	- all일 때
		- 메시지가 모든 `in-sync replica`에 전달된 뒤에 브로커로부터 성공했다는 응답 받음
		- 가장 안전한 형태
		- 최소 2개 이상의 브로커가 해당 메시지를 가지고 있음
		- 충돌이 나도 유실되지 않음
		- 지연 시간 길어짐
	> 신뢰성과 지연시간 사이에는 trade-off 관계가 있음


### 시리얼라이저

> 카프카가 기본적으로 포함하고 있는 시리얼라이저로는 모든 데이터를 직렬화할 수는 없음
>     - > 범용 시리얼라이저(Avro, Thrift, Protobuf), 커스텀 시리얼라이저
> 	    - 범용 시리얼라이저가 권장됨

#### 아파치 에이브로

- 언어 중립적인 데이터 직렬화 형식
- 언어에 독립적인 JSON 형식의 스키마로 기술됨
- 메시지를 쓰는 애플리케이션이 새로운 스키마로 전환해도 기존 스키마와 호환성이 유지된다면 게속해서 메시지 처리 가능
- 에이브로는 레코드를 읽을 때 스키마 전체를 필요
	- 전체 스키마를 저장할 경우 전체 레코드 사이즈가 2배 이상이 될 수 있음
		- `스키마 레지스트리`라는 아키텍처 패턴 사용
			- 모든 스키마를 레지스트리에 저장
			- 카프카에 쓰는 레코드에는 사용된 스키마의 고유 식별자만 심어주면 됨

### 인터셉터

- 카프카 클라이언트의 코드를 고치지 않으면서 그 작동을 변경해야 하는 경우
- 모니터링, 정보 추적, 표준 헤더 삽입 등의 용도로 사용
	- 레코드에 메시지가 생성된 위치에 대한 정보를 심어 메시지의 전달 경로 추적 또는 민감한 정보 삭제 처리 가능
	- `ProducerInterceptor` 인터셉터
		- `ProducerRecord<K, V> onSend(ProducerRecord<K, V> record)`
			- 프로듀서가 레코드를 브로커로 보내기 전 직렬화되기 직전에 호출
			- 이 메서드 재정의 시, 보내질 레코드에 담긴 정보 조회/수정 가능
		- `void onAcknowledgement(RecordMetadata metadata, Exception exception)`
			- 브로커가 보낸 응답을 클라이언트가 받았을 때 호출
			- 응답을 변경할 수는 없지만, 담긴 정보는 읽을 수 있음

### 쿼터, 스로틀링

- 쿼터
	- 쓰기 / 읽기 속도 제한
		- 쓰기 쿼터 [produce quota]
		- 읽기 퉈터 [consume quota]
		- 요청 쿼터 [request quota]