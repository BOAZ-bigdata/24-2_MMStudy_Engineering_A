# 7장 신뢰성 있는 데이터 전달

## 7.1 신뢰성 보장
카프카가 보장하는 것
- 파티션 안의 메시지들의 순서 보장
- 메시지는 인-싱크 레플리카의 파티션에 쓰여진 뒤에야 커밋된 것으로 간주된다.
- 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않는다.
- 컨슈머는 커밋된 메시지만 읽을 수 있다.

## 7.2 복제
- 각 파티션은 다수의 레플리카를 가질 수 있으며 그 중 하나가 리더가 됨
- 모든 이벤트들은 리더 레플리카에 쓰여지며 대체로 리더 레플리카에 의해 읽혀진다.
- 만약 리더가 작동 불능 상태가 되면 인-싱크 레플리카 중 하나가 새 리더가 된다.

## 7.3 브로커 설정

### 7.3.1 복제 팩터
복제 개수를 지정할 수 있다. 처리량, 종단 지연, 비용 등 다양한 트레이드 오프를 잘 고려해야 한다.

### 7.3.2 언클린 리더 선출
인-싱크 레플리케이션이 하나 남은 상황에서 해당 파티션이 다운될 경우 아웃-싱크 레플리케이션이 파티션 리더가 되는 것을 언클린 리더 선출이라고 한다. 카프카는 이러한 기본 설정을 false로 하여 방지하고 있다.

### 7.3.3 최소 인-싱크 레플리카
따라서 min.insync.replicas 설정을 통해 최소로 유지해야 하는 인-싱크 레플리카 개수를 잡아줄 수 있다. 이 개수를 충족시키지 못한다면, 쓰기 요청 시 `NotEnoughReplicasException`이 발생하여 더 이상 쓰기를 할 수 없게 된다.

### 7.3.4 레플리카를 인-싱크 상태로 유지하기
카프카 브로커가 주키퍼로 하트비트를 보내는 시간, 리더로부터 데이터를 읽어오지 못하는 시간을 늘려 아웃-싱크 레플리카가 될 확률을 줄인다.

### 7.4.2 프로듀서 재시도 설정하기
에러 중에는 재시도 가능한 에러와 불가능한 에러가 있다. 재시도 가능한 에러의 경우, 재시도 횟수를 무한으로 하고 재시도를 하는 시간을 조정하는 것이 좋다.

### 7.5.2 컨슈머에서 명시적으로 오프셋 커밋하기
**정확한 시점에 정확한 오프셋을 커밋하자**  
마지막으로 읽어 온 메시지의 오프셋이 아닌, 마지막으로 처리된 메시지의 오프셋을 커밋하는 것을 잊지 말자.

**컨슈머는 재시도를 해야 할 수도 있다**  
재시도 가능한 에러가 발생했을 경우, 마지막으로 처리에 성공한 레코드의 오프셋을 커밋한다. 나중에 처리할 레코드들을 버퍼에 저장하고 컨슈머의 pause() 메소드를 호출하여 추가적인 poll 호출이 데이터를 리턴하지 않도록 한 뒤 레코드 처리를 계속한다.

또 다른 방법은 별도의 토픽에 쓴 뒤 계속 진행하는 것이다.