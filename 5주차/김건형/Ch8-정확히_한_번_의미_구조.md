# '정확히 한 번' 의미 구조

## 멱등적 프로듀서

> **멱등적 [idempotent]** : 동일한 작업을 여러 번 실행해도 한 번 실행한 것과 결과가 같은 서비스

- 프로듀서가 멱등성 의미 구조가 아닌 '최소 한 번' 의미 구조라면, 프로듀서가 메시지 전송을 재시도 함으로써 메시지가 최소 한 번 이상 도착할 수 있는 불확실성이 존재하게 됨
	- 재시도는 메시지 중복을 발생시킬 수 있음

> 파티션 리더가 프로듀서로부터 레코드를 받아 팔로워들에게 성공적으로 복제했지만, 프로듀서에게 응답을 보내기 전에 파티션 리더가 있는 브로커에 충돌이 발생한 경우, 프로듀서는 메시지를 재전송하게 됨
> -> 재전송된 메시지가 새 리더에 도착하여, 중복이 발생

카프카의 멱등적 프로듀서 기능은 자동으로 이러한 중복을 탐지하고 처리함

### 멱등적 프로듀서 작동 원리

- 멱등적 프로듀서 기능을 켜면 모든 메시지는 고유한 `프로듀서 ID`와 `시퀀스 넘버`를 가짐
	- 대상 토픽 및 파티션과 이 두 값을 합치면 각 메시지의 고유한 식별자
	- 각 브로커는 해당 브로커에 할당된모든 파티션들에 쓰여진 마지막 5개 메시지들을 추적하기 위해 이 교유 식별자 사용
- 브로커가 받은 적이 있는 메시지를 받게 될 경우, 적절한 에러를 발생시킴으로써 중복 메시지를 거부
	- 로깅, 지표에 반영은 되지만 사용자에게 경보를 보내지는 않음

#### 프로듀서에 장애가 발생한 경우

- 보통 새 프로듀서를 생성해서 장애가 난 프로듀서를 대체
	- 멱등적 프로듀서 기능이 켜져 있을 경우, 프로듀서는 초기화 과정에서 카프카 브로커로부터 프로듀서 ID를 생성받음
	- 트랜잭션 기능을 켜지 않았을 경우, 프로듀서를 초기화 할 때마다 완전히 새로운 ID가 생성됨
		- 새 프로듀서가 기존 프로듀서가 이미 전송한 메시지를 다시 전송할 경우, 브로커는 메시지에 중복이 발생했음을 알아차리지 못함

#### 브로커에 장애가 발생한 경우

- 컨트롤러는 장애가 난 브로커가 리더를 맡고 있던 파티션들에 대해 새 리더 선출
	- 리더는 새 메시지가 쓰여질 때마다 인-메모리 프로듀서 상태에 저장된 최근 5개의 시퀀스 넘버를 업데이트함
	- 팔로워 레플리카는 리더로부터 새로운 메시지를 복제할 때마다 자체적인 인-메모리 버퍼를 업데이트
	- 팔로워가 리더가 된 시점에는 이미 메모리 안에 최근 5개의 시퀀스 넘버를 가지고 있는 것
	-> 아무 이슈나 지연 없이, 새로 쓰여진 메시지의 유혀성 검증이 재개될 수 있는 것
- 예전 리더가 다시 돌아온다면
	- 브로커는 종료되거나 새 세그먼트가 생성될 때마다 프로듀서 상태에 대한 스냅샷을 파일 형태로 저장
	- 브로커가 시작되면 일단 파일에서 최신 상태를 읽어오고, 현재 리더로부터 복제한 레코드를 사용해서 프로듀서 상태 업데이트
	-> 브로커가 다시 리더를 맡을 준비가 된 시점이라면, 최신 시퀀스 넘버를 갖게 됨

### 멱등적 프로듀서의 한계

- 카프카의 멱등적 프로듀서를 프로듀서의 내부 로직으로 인한 재시도가 발생할 경우 생기는 중복만을 방지
	- 재시도 할 때 중복을 피할 수 있는 가장 쉬운 방법
- 여러 개의 인스턴스를 띄우거나 하나의 인스턴스에서 여러 개의 프로듀서를 띄우는 애플리케이션들에서, 프로듀서들 중 두 개가 동일한 메시지를 전송하려 시도할 경우, 멱등적 프로듀서는 중복을 잡아내지 못함

---

## 트랜잭션

- 카프카 스트림즈를 사용해서 개발된 애플리케이션에 정확성을 보장하기 위해 도입됨
- 스트림 처리 애플리케이션이 정확한 결과를 산출하도록 하기 위해, 각 입력 레코드는 정확히 한 번만 처리되어야 하며, 그 처리 결과 역시 정확히 한 번만 반영되어야 함
- 정확성이 중요한 스트림 처리 애플리케이션이라면 언제나 큰 도움이 됨
	- 특히 로직에 집적, 조인이 포함되어 있는 경우

### 트랜잭션이 해결하는 문제

- 애플리케이션 충돌으로 인한 재처리
	- 출력 토픽에는 이미 썼는데 입력 오프셋이 커밋되기 전에 애플리케이션이 충돌이 나는 경우
		- 몇 초가 지난 후 하트비트가 끊어지면서 리밸런스 발생, 컨슈머가 읽어오고 있던 파티션들은 다른 컨슈머로 재할당될 것
		- 컨슈머는 새로 할당된 파티션의 마지막으로 커밋된 오프셋으로부터 레코드를 읽어오기 시작
		- 마지막으로 커밋된 오프셋에서부터 충돌이 난 시점까지, 애플리케이션에 의해 처리된 모든 레코드들이 다시 처리되게 되며 출력 토픽에도 다시 쓰여지게 되고, 중복이 발생
- 좀비 애플리케이션에 의해 발생하는 재처리
	- 애플리케이션이 카프카로부터 레코드 배치를 읽어온 직후 뭔가를 하기 전에 멈추거나, 카프카로의 연결이 끊어지는 경우
		- 하트비트가 끊어지면서 애플리케이션은 죽은 것으로 간주되고, 해당 컨슈머에 할당되어 있던 파티션들은 컨슈머 그룹 내 다른 컨슈머들에게 재할당될 것
		- 그 사이 멈췄던 애플리케이션의 첫 번째 인스턴스가 다시 작동할 수 있음
			- 마지막으로 읽어 왔던 레코드 배치를 처리하고 결과를 출력 토픽에 씀
				- 좀비 상태에서 출력 토픽으로 데이터를 쓸 수 있으며, 중복된 결과가 발생될 수 있음

### 트랜잭션은 어떻게 '정확히 한 번'을 보장하는가

- 읽어 온 원본 메시지의 오프셋이 커밋되고 결과가 성공적으로 쓰여지거나, 둘 다 안 일어나거나 하는 부분적인 결과가 발생하지 않을 것이라는 보장이 필요
	- 카프카 트랜잭션은 `원자적 다수 파티션 쓰기`기능을 도입
		- 결과는 출력 토픽에, 오프셋은 `_consumer_offsets` 토픽에 쓰여짐
		- 트랜잭션을 시작해서 양쪽에 메시지를 쓰고, 둘 다 성공해서 커밋하거나 재시도를 위해 중단할 수 있다면, '정확히 한 번'의미 구조가 알아서 해주게 됨

#### 트랜잭션적 프로듀서

- 트랜잭션을 사용해서 원자적 다수 파티션 쓰기를 수행하기 위해서는 사용해야 함
- 일반 프로듀서와의 차이
	- `transactional.id` 설정이 잡혀 있고 `initTransactions()`를 호출해서 초기화해주는 것
