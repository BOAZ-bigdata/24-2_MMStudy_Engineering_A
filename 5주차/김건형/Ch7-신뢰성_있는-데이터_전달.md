
# 신뢰성 있는 데이터 전달

## 신뢰성 보장

### ACID

- A
	- Atomicity [원자성]
- C
	- Consistency [일관성]
- I
	- Isolation [격리성]
- D
	- Durability [지속성]

> - 카프카는 파티션 안 메시지들 간 순서를 보장
> -  클라이언트가 쓴 메시지는 모두 인-싱크 레플리카의 파티션에 쓰여진 뒤에 `커밋`된 것으로 간주됨
> - 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않음
> - 컨슈머는 커밋된 메시지만 읽을 수 있음


## 복제

- 카프카의 복제 메커니즘
	- 파티션 별로 다수의 레플리카를 유지한다는 특성과 함께 카프카의 신뢰성 보장의 핵심이라 할 수 있음
	- 하나의 메시지를 여러 개의 레플리카에 씀으로써 카프카는 충돌이 나더라도 메시지의 지속성[`D`]를 유지

## 브로커 설정

- 메시지 저장 신뢰성 관련된 카프카의 작동을 변경시키는 브로커의 설정 매개변수
	- 복제 팩터
		- 복제 팩터가 N이면, 각 브로커가 N대의 서로 다른 브로커에 N개 복제된다는 것
		- 복제 팩터가 N이면 N-1개의 브로커가 중단되더라도 토픽의 데이터를 읽거나 쓸 수 있음
		- 복제 팩터가 클수록 `가용성`과 `신뢰성`은 늘어나고, 장애가 발생할 가능성은 줄어듦
			- N배의 디스크 공간이 더 필요하다는 의미이기도 함 (*trade-off*)
			- 저장소와 네트워크에 필요한 비용 또한 증가함
	- 언클린 리더 선출
		- 브로커 단위에서만 가능
		- 리더가 작동 불능인데 인-싱크 레플리카가 없는 경우
			- 아웃-오브-싱크 레플리카가 새 리더가 될 수 없도록 하면, 예전 리더가 복구될 때까지 해당 파티션은 오프라인 상태가 됨 [**가용성 줄어듦**]
			- 아웃-오브-싱크 레플리카가 새 리더가 될 수 있도록 한다면, 새 리더가 동기화를 못 한 사이 이전 리더에 쓰여졌던 모든 메시지들이 유실, 컨슈머 입장에서의 일관성 역시 깨짐 [**일관성 줄어듦**]
	- 최소 인-싱크 레플리카
		- 커밋된 데이터를 N개 이상의 레플리카에 쓰고자 한다면, 인-싱크 레플리카의 최소값을 더 높게 잡아야 함

---
## 신뢰성 있는 시스템에서 프로듀서 사용하기

- 브로커와 마찬가지로, 프로듀서 역시 신뢰성이 있도록 설정해야 함
	 - 토픽별로 3개의 레플리카를 가지도록 브로커를 설정한 상태에서, 언클린 리더 선출 기능 끔 (`acks=1`)
		 - 카프카 클러스터에 커밋된 메시지는 유실되지 않음
		 - 프로듀서가 메시지를 전송해서 리더가 프로듀서에게 성공적으로 쓰여졌다는 응답을 보낸 직후 장애가 나는 경우
			 - 데이터는 레플리카로 복제되지 않은 상태
			 - 다른 레플리카들은 여전히 인-싱크 상태로 간주되기 때문에, 이 중 리더가 선출됨
			 - 하지만 프로듀서의 입장에서, 레플리카에 쓰여지지 않은 메시지는 유실됨
				 - 시스템의 일관성은 유지되는 것
	- 토픽별로 3개의 레플리카를 가지도록 브로커를 설정한 상태에서, 언클린 리더 선출 기능 끔 (`acks=all`)
		- 위와 같은 충돌의 경우 카프카는 `Leader not Available`응답을 보낼 것
		- 프로듀서가 에러 처리를 하지 않고 재시도도 하지 않을 경우 메시지는 유실됨

> 신뢰성 요구 조건에 맞는 올바른 `acks` 설정을 사용해야 함
> 설정과 코드 모두에서 에러를 올바르게 처리해야 함

---
## 신뢰성 있는 시스템에서 컨슈머 사용하기

- 메시지 처리 먼저, 오프셋 커밋은 나중에
- 커밋 빈도는 성능과 크래시 발생시 중복 개수 사이의 trade-off
- 정확한 시점에 정확한 오프셋 커밋하기
- 리밸런스
- 컨슈머는 재시도를 해야 할 수도 있음
- 컨슈머가 상태를 유지해야 할 수도 있음