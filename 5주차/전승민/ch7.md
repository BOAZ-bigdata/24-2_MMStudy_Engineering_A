# 신뢰성 있는 데이터 전달
- 카프카는 신뢰성 있는 데이터 전달에 매우 유연함

## 신뢰성 보장
- 보장 : 서로 다른 상황에서도 시스템이 지킬 것이라 보장되는 행동을 의미함
- 가장 잘 알려진 신뢰성 보장은 RDB가 지원하는 ACID임
  - ACID는 원자성,일관성,격리성,지속성을 의미함
  - 어떤 DB가 ACID를 준수하면, 트랜잭션 처리 관련해서 어떠한 행동을 보장한다는 의미임
- 이러한 보장을 바탕으로 여기에 의존해 애플리케이션을 작성함
- 카프카가 보장하는것
  - 카프카는 파티션 안의 메시지들 간에 순서를 보장함
  - 클라이언트가 쓴 메시지는 모든 인-싱크 레플리카의 파티션에 쓰여진 후, '커밋'된 것으로 간주됨
  - 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않음
  - 컨슈머는 커밋된 메시지만 읽을 수 있음
- 신뢰성 있는 시스템을 구축하는 데는 트레이드 오프(하나 결정할때, 다른거 포기하는거)가 있듯이, 카프카는 이런 트레이드 오프들을 조절할 수 있도록 해 신뢰성 보장

## 복제
- 카프카의 복제 메커니즘은 파티션벼로 다수의 레플리카를 유지한다는 특성과 함께 카프카의 신뢰성 보장의 핵심임
### 리마인드
- 카프카 토픽은 기본적인 데이터 구성 요소인 파티션으로 이루어짐
- 하나의 파티션은 하나의 디스크에 저장됨
- 파티션에 저장된 이벤트들은 순서가 보장됨
- 각 파티션은 다수의 레플리카를 가질 수 있으며, 그중 하나가 리더가 됨
- 모든 이벤트들은 리더 레플리카에 쓰여지고 읽힘
- 다른 레플리카들은 리더와 동기화를 맞추면서 최신화를 하면됨
- 리더가 작동 불가능하면, 인-싱크 레플리카 중 하나가 새 리더가 됨
  - 레플리카는 파티션의 리더 레플리카이거나, 몇 가지 조건을 만족하는 팔로워 레플리카인 경우 인-싱크 상태인 것으로 간주됨
  - 동기화가 풀린( 아웃-오브-싱크) 레플리카는 주키퍼와 다시 연결되고, 리더 파티션에 쓰여진 가장 최신 메시지를 따라 잡으며, 다시 인-싱크 레플리카가 됨
- 동기화가 늦은 인-싱크 레플리카는 프로듀서와 컨슈머를 느리게 만들 수 있음
  - 프로듀서와 컨슈머는 커밋되기 전, 모든 인-싱크 레플리카가 해당 메시지를 받을 때까지 기다려야 하기 때문
  - 인-싱크 레플리카 수가 줄어들면 파티션의 실질적인 복제 팩터가 줄어들어 중단 시간이 길어지거나, 데이터 유실 가능성이 높아짐
## 브로커 설정
- 카프카의 작동을 변경시키는 브로커의 설정 매개변수는 3개 있음
  - 이 매개변수들은 브로커 단위에서 적용되어 시스템 안의 모든 토픽들을 제어할 수 있고 토픽 단위에서 적용되어 특정 토픽의 작동을 제어함
  - 토픽 단위에서 신뢰성 트레이드오프를 제어하는 것은 신뢰성이 필요한 토픽과 아닌 토픽을 같은 카프카 클러스터에 저장할 수 있음을 의미함
### 복제 팩터
- 토픽 단위 설정은 replication.factor에
- 자동으로 생성되는 토픽들에 적용되는 브로커 단위 설정은 default.replication.factor에 설정함
- 복제 팩터가 클수록 가용성과 신뢰성은 늘어나 장애 발생할 가능성이 줄어들지만, 그만큼 디스크 공간이 필요함
- 토픽에 몇 개의 레플리카가 적절한지 결정할때 고렬할 것
  - 가용성 : 레플리카 수가 더 많을 수록 가용성은 더 늘어남
  - 지속성 : 각 레플리카는 파티션 안의 모든 데이터의 복사본임, 복사본이 많을 수록, 데이터 유실 가능성이 낮아짐
  - 처리량 : 레플리카가 추가될 때마다 브로커간 트래픽이 늘어남
  - 종단 지연 : 쓰여진 메시지를 컨슈머가 읽을 수 있을려면 모든 인-싱크 레플리카에 복제되야함
    - 레플리카 수가 많을 수록, 이들 중 하나가 느려져 컨슈머도 같이 느려짐
  - 비용 : 레플리카가 많아질 수록 저장소와 네트워크에 들어가는 비용역시 증가함
- 랙 단위 사고 방지를 위해 브로커들은 서로 다른 랙에 배치한뒤 broker.rack 브로커 설정 매개변수에 랙 이름을 잡아줄 것을 권장함
  - 랙 이름을 설정함으로써, 카프카는 파티션의 레플리카들이 서로 다른 랙에 분산되어 저장하도록 해 가용성을 높임

### 언클린 리더 선출
- 이 설정은 브로커 단위(클러스터 단위)에서만 가능함
- unclean.leader.election.enable 매개변수를 사용, 기본값은 false
- 파티션의 리더가 더 이상 사용 가능하지 않을 경우 인-싱크 레플리카 중 하나가 새 리더가 됨
  - 커밋된 데이터에 유실이 없을 보장한다는 점에서 이러한 리더 선출을 '클린' 이라고 부름
  - 커밋된 데이터 자체가 모든 인-싱크 레플리카에 존재하는 데이터이기 때문
- unclean.leader.election.enable 기본값이 false인 이유는 아웃-오브-싱크 레플리카는 리더가 될 수 없더록 했음
  - 데이터 유실에 있어 가장 안전한 옵션이기 때문
### 최소 인-싱크 레플리카
- 토픽과 브로커 단위 모두 min.insync.replicas 설정에서 잡을 수 있음
- 커밋된 데이터를 2개 이상의 레플리카에 쓸려면, 인-싱크 레플리카의 최소값을 더 높게 잡아줘야함
  - ex) 토픽에 레플리카가 3개 있고 min.insync.replicas를 2로 잡았으면, 프로듀서들은 3개의 레플리카 중 최소 2개가 인-싱크 상태인 파티션에만 쓸 수 있음
  - 3개중 2개의 레플리카가 작동 불능일 경우, 브로커는 더 이상 쓰기 요청을 받을 수 없음
    - 예외를 받게됨
  - 컨슈머는 계속해서 존재하는 데이터를 읽을 수 있음
  - 이때 인-싱크 레플리카가 하나만 남을 경우 레플리카는 읽기 전용이 되어버림
  - 이렇게 되면 언클린 리더 선출이 발생할때 사라질 데이터를 쓰거나 읽는 것을 방지할 수 있음
### 레플리카를 인-싱크 상태로 유지하기
- 아웃-오브-싱크 레플리카는 전반적인 신뢰성을 낮추므로, 가능한 피해야함
  - 아웃-오브-싱크는 주키퍼와의 연결이 끊어지거나, 리더 업데이트 내역을 따라가는데 실패해서 복제 랙이 발생할때
  - 이 두가지 상황에 대해 카프카 클러스터의 민감도를 조절할 수 있는 브로커 설정 두가지가 있음
  - zookeeper.session.timout.ms : 카프카 브로커가 주키퍼로 하트비트 전송을 멈출 수 있는 최대 시간 정의함
  - replica.lag.time.max.ms에 설정된 값보다 더 오랫동안 리더로부터 데이터를 읽어 오지 못하거나, 리더에 쓰여진 최신 메시지를 따라잡지 못한경우 아웃-오브-싱크 상태임
### 디스크에 저장하기
- 카프카는 메시지를 받은 레플리카의 수에만 의존할 뿐, 디스크에 저장되지 않은 메시지에 대해서도 응답함
- 카프카는 세그먼트를 교체할 때와 재시작 직전에만 메시지를 디스크로 플러시하며, 그 외의 경우에는 리눅스의 페이지 캐시 기능에 의존함
  - 데이터의 복제본을 가지고 있는 서로 다른 랙이나 가용 영역에 위치한 세 대의 장비가 리더의 디스크에 쓰는 것보다 더 안전하기 때문
  - 서로 다른 랙이나 가용 영역에서 동시에 장애가 발생할 가능성은 거의 없기 때문

## 신뢰성 있는 시스템에서 프로듀서 사용하기
- 신뢰성이 가장 높은 설정을 브로커에 적용해도, 프로듀서 역시 신뢰성 있도록 설정을 하지 않으면, 데이터가 유실될 수 있음
- 카프카에 메시지를 쓰는 애플리케이션을 개발때 고려할 2가지가 있음
  - 신뢰성 요구 조건에 맞는 올바른 acks 설정 사용
  - 설정과 코드 모두에서 에러를 올바르게 처리
### 응답 보내기
- acks = 0 : 프로듀서가 네트워크로 메시지를 전송한 시점에서 메시지가 카프카에 성공적으로 쓰여진것으로 간주됨
- akcs = 1 : 리더가 메시지를 받아서 파티션 데이터 파일에 쓴 직후 응답 또는 에러를 보낸다는 것을 의미함
  - 리더에 메시지가 성공적으로 작성되고, 클라이언트에 응답이 간 상태에서, 팔로워 복제가 완료되기전에 리더가 정지하면, 데이터 유실이 있을 수 있음
  - 불완전 복제 파티션이 발생할 수 있음
-acks = all : 리더가 모든 인-싱크 레플리카가 메시지를 받아갈 때까지 기다렸다가 응답하거나 에러를 보낸다는 것을 의미함

### 프로듀서 재시도 설정하기
- 프로듀서가 자동으로 처리해주는 에러
- 프로듀서 라이브러리르 사용하는 개발자들이 처리해야 하는 에러
- 에러를 처리하는데 여러 방법이 있음

## 신뢰성 있는 시스템에서 컨슈머 사용하기
- 읽는 방법
- 컨슈머는 카프카에 커밋된 데이터만을 읽을 수 있음
- 모든 인-싱크 레플리카에 쓰여진 다음부터 읽을 수 있음
  - 컨슈머는 일관성이 보장된 데이터만 읽음
  - 컨슈머는 추적으로 통해 메시지 읽는 것이 누락되지 않게 함
  - 파티션으로부터 데이터를 읽어 올때, 컨슈머는 메시지를 배치 단위로 읽어온 뒤 배치별로 마지막 오프셋을 확인하고,
  - 브로커로부터 받은 마지막 오프셋 값에서 시작하는 다른 메시지 배치를 요청함
  - 이 과정을 통해 카프카 컨슈머는 메시지 누락 없이, 언제나 새로운 데이터를 올바른 순서로 읽음
  - 컨슈머가 읽어온 오프셋을 커밋하는 이우
    - 읽고 있는 각 파티션에 대해 어디까지 읽었는지를 지정해 둬야 해당 컨슈머나 다른 컨슈머가 어디서 작업을 해야하는지 알 수 있기 때문
- 커밋된 메시지 vs 커밋된 오프셋
    - 커밋된 메시지 : 모든 인-싱크 레플리카에 쓰여져서 컨슈머가 읽을 수 있는 메시지를 의미함
    - 커밋된 오프셋 : 컨슈머가 특정 파티션 어느 오프셋까지의 모든 메시지를 받아서 처리를 완료했는지를 알리기 위해 카프카에 보낸 오프셋
### 신뢰성을 위한 컨슈머 설정
- group.id
- auto.offset.rest
- enable.auto.commit
- auto.commit.interval.ms

### 컨슈머에서 명시적으로 오프셋 커밋하기
1. 메시지 처리 먼저, 오프셋 커밋은 나중에
2. 커밋 빈도는 성능과 크래시 발생시 중복 개수 사이의 트레이드 오프임
3. 정확한 시점에 정확한 오프셋을 커밋해야함
4. 리밸런스
5. 컨슈머는 재시도를 해야 할 수도 있음
6. 컨슈머가 상태를 유지해야 할 수도 있음

## 시스템 신뢰성 검증하기
- 설정 검증, 애플리케이션 검증, 프로덕션 환경에 배포된 애플리케이션 모니터링

### 설정 검증하기
- 애플리캐이션 로직과 격리된 채 브로커와 클라이언트 설정을 검증함
  - 우리가 선택한 구상이 요구 조건을 충족시킬 수 있는지 확인하는데 도움이 됨
  - 시스템의 예상 작동을 추론해 보기 위한 좋은 방법임
### 애플리케이션 검증하기
- 애플리케이션이 우리가 필요로 하는 보장을 해주는지를 확인함
- 애플리케이션 로직이 카프카의 클라이언트 라이브러리와 상호작용하는 커스텀 에러 처리 코드, 오프셋 커밋, 리밸런스 리스너 같은 곳을 확인함
- 테스트 방법에는 여러가지가 있음
### 프로덕션 환경에서 신뢰성 모니터링하기
- 클러스터의 상태 모니터링 하는 것 처럼 클라이언트와 전체 데이터 흐름 모니터링 하는 것 역시 중요함
- 자바 클라이언트들을 모니터링 할 수 있도록 JMX 지표를 포함함
  - 신뢰성 : 레코드별 에러율, 재시도율 지표가 중요함
  - 컨슈머 : 컨슈머 랙 지표가 중요함
  - 카프카 브로커는 브로커가 클라이언트로 보내는 에러 응답률을 보여주는 지표들도 있음
