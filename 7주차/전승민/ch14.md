# 스트림 처리
- 카프카는 '카프카 스트림즈'라 불리는 강력한 스트림 처리 라이브러리를 클라이언트 라이브러리의 일부로서 포함함
  - 이 라이브러리를 사용하면 외부 처리 프레임워크에 의존할 필요 없음
- 데이터 스트림
  - 무한히 늘어나는 데이터 세트를 추상화한 것
  - 데이터세트가 계속해서 추가되기 때문에 '무한'이라고 함
- 이벤트 스트림
  - 우리가 분석하고자하는 모든 비즈니스 활동을 나타낼 수 있음
  - 이메일 전송, 게임에서 이동 등..
  - 이벤트 스트림에는 순서가 있음
  - 데이터 레코드는 불변함
    - 이벤트는 한 번 발생하고 나서는 절대로 고칠 수 없음
    - 대신 기존 이벤트가 취소되었다는 의미의 추가적인 이벤트가 스트림에 작성됨
  - 이벤트 스트림은 재생이 가능함
    - 새로운 분석 방법을 시도하거나, 감사를 수행하기 위해 몇 달 전, 몇 년 전 발생한 raw stream도 그대로 재생할 수 있음
- 스트림 처리 :
  - 하나 이상의 이벤트 스트림을 계속해서 처리하는 것을 의미함
  - 요청 응답
    - 응답 시간이 1 밀리초 미만 ~ 몇 밀리초 수준인 패러다임으로, 가장 지연이 적은 패러다임임
    - 처리 방식은 블로킹 방식
    - POS 시스템, 신용카드 결제 시스템이 예시
  - 배치 처리
    - 지연이 크지만, 처리량 역시 큼
    - 필요한 모든 입력 데이터를 읽고, 모든 출력 데이터를 쓰고, 다음 번 실행까지 대기하는 식임
  - 스트림 처리
    - 연속적이고, 논블로킹 방식
  ## 스트림 처리 개념
  - 데이터 처리와 매우 비슷함
  - 데이터를 읽고 무엇인가 처리를 한 뒤 어딘가에 결과물을 쓰는 식의 코드를 작성하는 것
  ### 토폴로지
  - 스트림 처리 애플리케이션은 하나 이상의 처리 토폴로지를 포함함
    - 하나 이상의 소스 스트림, 스트림 프로세스의 그래프, 하나 이상의 싱크 스틺이 서로 연결된 것을 의미함
    - 각각의 스트림 프로세서는 이벤트를 변환하기 위해 이벤트 스트림에 가해지는 연산 단계라고 할 수 있음
  ### 시간
  - 스트림 처리에서 가장 중요한 개념이며, 가장 혼란스러운 개념
  - 이벤트 시간
    - 다루고자하는 이벤트가 발생하여 레코드가 생성된 시점
  - 로그 추가 시간
    - 이벤트가 카프카 브로커에 전달되어 저장된 시점(접수 시간이라고도 불림)
  - 처리 시간
    - 스트림 처리 애플리케이션이 연산을 수행하기 위해 이벤트를 받은 시간
    - 이벤트가 발생한 뒤 몇 밀리초, 몇 시간, 며칠 뒤일 수도 있음
    - 동일한 이벤트라도 정확히 언제 스트림 처리 애플리케이션이 이벤트를 읽었느냐에 따라 서로 다른 타임스탬프가 주어짐
    - 같은 애플리케이션 안에서도 스레드별로 다를 수 있음
    - 신뢰성이 떨어져 가능하면 피하는것이 좋음
  - 상태
    - 각각의 이벤트를 따로따로 처리해야하는 경우와 다수의 이벤트가 포함되는 작업이 있음
    - 이벤트에 따라 여러 가지 조건을 고려해야하고 정보를 추적 관리하는 것을 상태라고 부름
  - 로컬 혹은 내부 상태
    - 스트림 처리 애플리케이션의 특정 인스턴스에서만 사용할 수 있는 상태임
    - 애플리케이션에 포함되어 구동되는 내장형 인메모리 데이터베이스를 사용해서 유지 관리됨
    - 로컬은 속도가 엄청나게 빠르지만 사용 가능한 메모리 크기의 제한을 받음
   - 외부 상태
     - 카산드라와 같은 NoSQL 시스템을 사용해서 저장됨
     - 접근이 용이하지만, 다른 시스템을 추가하면 지연 증간, 복잡도 증가, 가용성 문제가 발생함
### 스트림-테이블 이원성
- 테이블과 달리 스트림은 변경 내역을 저장함
- 스트림은 변경을 유발하는 이벤트의 연속임
- 테이블을 스트림으로 변환하기 위해서는 CDC 솔루션과 카프카 커넥터를 활용함
- 스트림을 테이블로 변환하기 위해서는 스트림을 구체화 작업을 해야함
### 시간 윈도우
- 대부분의 스트림 작업은 시간을 윈도우라 불리는 구간 단위로 잘라서 처리함
  - 이동 평균을 계산하거나, 가장 많이 팔린 상품 계산, 시템의 99분위 하부를 찾아내는 식..
  - 두 스트림을 조인하는 작업도 마찬가지
  - 고려할 사항
    - 윈도우 크기
    - 시간 윈도우의 진행 간격
    - 윈도우를 업데이트할 수 있는 시간
- 처리 보장
  - 스트림 처리 애플리케이션에 있어서 핵심적인 요구 조건 중 하나는 장애가 발생해도 각각의 레코드를 한 번만 처리할 수 있는 능력임
  - '정확히 한번' 보장이 없는 경우 정확한 결과가 요구되는 상황에서는 사용될 수 없음
## 스트림 처리 디자인 패턴
- 모든 스트림 처리 시스템은 서로 다름
### 단일 이벤트 처리
- 가장 단순한 스트림 처리 패턴은 각각의 이벤트를 개별적으로 처리하는 것임
- map/filter 패턴이라고도 알려짐
- 불필요한 이벤트를 스트림에서 걸러 내거나 각 이벤트를 변환하기 위해 사용되는 경우가 많기 때문
- 이 패턴에서 스트림 처리 애플리케이션은 스트림으 이벤트를 읽어와서 각각의 이벤트를 수정한 뒤, 수정된 이벤트를 다른 스트림에 씀
### 로컬 상태와 스트림 처리
- 대부분의 스트림 처리 애플리케이션은 윈도우 집계와 같이 정보의 집계에 초점을 맞춤
  - 주식 최저가와 최고가를 찾고 이평을 구하는 것이 대표적인 예시
- 스트림의 상태를 유지할 필요가 있음
- 고려할거
  - 메모리사용
  - 영속성
  - 리밸런싱
### 다단계 처리/파티셔닝
- 예시 읽어보기..
### 외부 검색을 사용하는 처리: 스트림-테이블 조인
- 스트림 처리를 할 때는 외부 데이터를 스트림과 조인해야 함
- 거래 내역을 데이터베이스에 저장된 규칙을 사용해서 검증하거나 사용자 클릭 내역을 사용자 정보와 합쳐서 저장시키는 방식..
- 이런 외부 검색 수행하는 방법은 외부 검색이 각각의 레코드를 처리하는 데 있어서 상당한 지연을 발생시킨다는 것임
- 성능과 가용성을 다 잡기 위해서 스트림 처리 애플리케이션 안에 데이터베이스에 저장된 데이터를 캐시할 필요가 있음
- 캐시 관리가 힘들음..
  - 데이터베이스 테이블에 가해지는 모든 변경점을 이벤트 스트림에 담을 수 있다면, 스트림 처리 작업이 이 스트림 받아와 캐시를 업데이트 하는데 사용될 수 있음
- =>스트림 중 하나가 로컬에 캐시된 테이블에 대한 변경 사항을 나타내기 때문에 이것을 스트림-테이블 조인이라고 부름
### 테이블-테이블 조인
- 윈도우 처리되지 않는 연산이며, 작업이 실행되는 시점에서의 양 테이블의 현재 상태를 조인함
### 스트리밍 조인
- 두 개의 실제 이벤트 스트림을 조인해야할 경우..
- 스트리밍 조인을  '윈도우 조인'이라고 부름
  - 한쪽 스트림에 포함된 이벤트를 같은 키값과 함께 같은 시간 윈도우에 발생한 다른 스트림 이벤트와 맞춰야하기 때문
### 비순차 이벤트
- 잘못된 시간에 스트림에 도착한 이벤트를 처리하는거 등...
  - 와이파이 끊기고 나서 재접속할 때 몇 시간치의 이벤트를 한꺼번에 재전송함
- 애플리케이션에서 해야 할 일
  - 이벤트 순서가 벗어났음을 알아차려야 함
  - 비순차 이벤트의 순서를 복구할 수 있는 시간 영역을 정의
  - 순서를 복구하기 위해 이벤트를 묶을 수 있어야 함
  - 결과를 변경할 수 있어야 함
### 재처리하기
- 두 가지 변형 패턴이 있음
  - 새로 개선된 버전의 스트림 처리 애플리케이션
  - 기존의 스트림 처리 애플리케이션 버그를 고친 뒤 이벤트 스트림을 재처리해서 결과를 다시 산출하고자 함
### 인터랙티브 쿼리
- 카프카 스트림즈는 스트림 처리 애플리케이션의 상태를 쿼리하기 위한 유연한 API를 포함함
## 예제로 보는 카프카 스트림즈
- 읽어보기..
## 카프카 스트림즈: 아키텍처
### 토폴로지 생성하기
- 모든 스트림즈 애플리케이션은 하나의 토폴로지를 구현하고 실행함
- 토폴로지는 다른 스트림 처리 프레임워크에서는 DAG라고 불림
- 토폴로지는 프로세서들로 구성되는데, 각각의 프로세서들은 노드에 대응함
  - 프로세서들은 필터,맵,집계 연산과 같은 데이터에 대한 처리 작업을 구현함
### 토폴로지 최적화 하기
- DSL로 개발되었기에 최적화되지 않은 상태일 수 있음
- 카프카 스트림즈 애플리케이션의 실행은 3단계로 이루어짐
  1. KStream,KTable 객체를 생성하고 필터,조인과 같은 DSL 작업을 수행해 논리적 토폴로지를 정의
  2. StreamBuilder.build() 메소드가 논리적 토폴로지로부터 물리적 토폴로지를 생성함
  3. KafkaStreams.start()가 토폴로지를 실행시킴
  - 논리적 토폴로지에서 물리적 토폴로지가 생성되는 두 번째 단계가 최적화가 적용되는 곳임
  - 설정값을 통해 최적화 방식을 활성화 할 수 있음
### 토폴로지 테스트하기
- TopologyTestDriver 툴을 활용함
### 토폴로지 규모 확장하기
- 카프카 스트림즈는 하나의 애플리케이션 인스턴스 안에 다수의 스레드가 실행될 수 있게 해
- 규모 확장과 서로 다른 애플리케이션 간에 부하 분산이 이루어지도록 함
- 카프카 스트림즈 엔진은 토폴로지의 실행을 다수의 태스크로 분할해 병렬 처리함
- 스트림즈 엔진은 애플리케이션이 처리하는 토픽의 파티션 수에 따라 태스크 수를 결정함
그림 보기..(p.456,p.457)
### 장애 처리하기
- 장애가 발생해 재시작이 필요한 경우, 장애가 발생하기 전 마지막으로 커밋된 오프셋을 카프카에서 가져옴으로써 처리하던 스트림의 마지막으로 처리된 지점부터 재개하면 됨
- 로컬 저장소가 유실되었을 경우,스트림즈 애플리케이션은 항상 카프카로부터 체인지 로그를 읽어와서 로컬 상태 저장소를 복구함
- 태스크 고가용서을 위해 카프카의 컨슈머 코디네이션 기능을 사용함
### 스트림 처리 활용 사례
- 고객 서비스
- 사물 인터넷
- 사기 탐지
## 스트림 처리 프레임워크 선택하기
- 데이터 수집
- 밀리초 단위 작업
- 비동기 마이크로서비스
- 준 실시간 데이터 분석
- 시스템 운용성
- 사용 및 디버깅 용이성
- 커뮤니티
