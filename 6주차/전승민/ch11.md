# 보안
- 보안은 컴포넌트별로 따로따로 다뤄지기보다 전체 시스템에 대해 다뤄줘야 할 부분임
## 보안 설정 적용하기
- 인증 : 사용자가 누구인지 식별함
- 인가 : 사용자가 무엇을 할 수 있는지 결정
- 암호화 : 누설과 위조로부터 데이터를 보호함
- 감사 : 사용자가 무엇을 했는지, 하려 했는지를 추적
- 쿼터 : 자원을 얼마나 많이 사용할 수 있는지 조절

- 안전한 카프카 클러스터 특징
  - 클라이언트 진정성
    - 브로커는 전송된 메시지가 정말 클라이언트로부터 온 것인지 인증해야함
  - 서버 진정성
    - 리더 브로커로 메시지 보내기 전에, 클라이언트는 해당 연결이 실제 브로커와 맺어진 것임을 검증해야함 
  - 기밀성
  - 무결성
    - 안전하지 못한 네트워크를 통해 전송되는 모든 데이터에 메시지 다이제스트를 포함하여 내용물 변조시 알 수 있어야 함
  - 접근 제어
    - 접근 권한 확인 해야함
  - 감사 가능성
    - 클라이언트가 수행한 모든 작업을 보여주는 감사용 기록이 남아야 함
  - 가용성
    - 공격에 대비하기 위해 쿼터와 제한을 두어야 함
## 보안 프로토콜
- 카프카 브로커에는 1개 이상의 엔드포인트를 가진 리스너 설정이 있음
- 클라이언트로부터의 연결을 받는 것이 이 리스너임
- 리스너 각각 보안 설정을 가질 수 있음
- 보안 프로토콜은 인증과 전송되는 데이터의 암호화 수준을 결정함
- 카프카는 2개의 표준 기술 TLS 와 SASL을 사용해 4개의 보안 프로토콜을 지원함
- SSL : TLS 이전 버전의 이름이며 이렇게도 불림, 서버,클라이언트 사이의 인증과 암호화 지원
- SASL: 연결 지향 프로토콜에서 서로 다른 메커니즘을 사용한 인증을 지원하는 프레임워크
- 각 카프카 보안 프로토콜은 전송 계층와 인증 계층을 조합해서 정의됨
- PLAINTEXT
  - 이 전송 계층에는 인증이 존재하지 않음
  - 사설 네트워크 안에서 인증이나 암호화가 필요없을 정도로 민감하지 않은 데이터를 처리할 때만 적합함
- SSL
  - 이 전송 계층은 선택적으로 클라이언트 SSL 인증을 수행할 수 있음
  - 안전하지 않은 네트워크에서 적절함
- SASL_PLAINTEXT
  - SASL 인증과 PLAINTEXT 전송 계층이 합쳐진 것
  - 암호화는 지원하지 않기에 사설 네트워크 안에서만 적합함
- SASL_SSL
  - SASL인증과 SSL 전송 계층이 합쳐진 것임
  - 안전하지 않은 네트워크에서 적절함
cf)
  - TLS : 인터넷에서 가장 많이 사용되는 암호화 프로토콜 중 하나임
## 인증
- 서버와 클라이언트 사이에서 서로의 신원을 확인하는 과정
### SSL
 1.TLS 설정하기
 - 브로커 리스너에 SSL 혹은 SASL_SSL을 사용해 TLS 활성화하면, 브로커에는 비밀키와 인증서를 포함하고 있는 키스토어가 설정되야함
 - 클라이어엔트에는 인증서를 포함하는 트러스트스토어가 설정되야함
 - 예제 살펴보기
2. 고려사항
  - 다른 보안 프로토콜과 마찬가지로, 잠재적인 위협과 미션 크리티컬한 애플리케이션에 적용시 취약성을 완화함
  - 비밀 키 저장하는 키스토어는 기본적으로 파일시스템상 저장되므로, 키스토어에 접근할 수 있는 권한을 제한할 필요가 있음
  - TLS 핸드셰이크는 자원을 많이 잡아 먹고 네트워크 스레드에 많은 시간을 씀
    - 불안전한 네트워크에서 TLS 사용하는 리스너는 브로커의 가용성을 보호하기 위해 쿼터나 제한을 통해 거부 공격을 막아냄
### SASL
- 카프카 프로토콜은 SASL을 사용한 인증을 지원함
- 전송 계층에 SASL과 TLS를 함께 사용함으로써 인증고 암호화를 동시에 지원하는 안전한 채널을 사용할 수 있음
- SASL 인증은 서버가 챌린지를 내놓으면 클라이언트가 응답을 보내는 과정을 순서대로 수행하는 식임
- 카프카 브로커는 SASL 메커니즘과 함께 커스터마이즈 가능한 콜백을 함께 지원함
- GSSAPI
  - 케르베로스 인증이 지원되며, 케르베로스 서버와 통합하는데 사용됨
- PLAIN
  - 사용자 이름/비밀번호 ... 사용해서 비밀번호를 검증하는 서버측 커스텀 콜백과 함께 사용됨
- SCRAM-SHA-256 and SCRAM-SHA-512
  - 사용자 이름/비밀번호 인증
- OAUTHBEARER
  - 토큰을 사용한 인증, 표준화된 OAuth 서버에서 부여된 토큰을 추출하고 검증하는 커스텀 콜백과 함께 사용됨
### 재인증
- 케르베로스나 OAuth는 유효기간이 있는 자격 증명을 사용함
- 카프카는 기존 자격 증명이 만료되기 전 새로운 자격 증명을 얻어오기 위해 백그라운드에서 돌아가는 로그인 스레드를 사용하지만
- 새로운 자격 증명은 기본적으로 새로운 연결에만 적용되도록 되어 있음
- 오랫동안 유지되는 연결은, 인증이 만료된 후에도 계속 작동할 수 있음
- connections.max.reatuth.ms 설정 옵션을 통해 SASL로 인증된 연결을 재인증 할 수 있음
### 무중단 보안 업데이트
- 카프카 정비는 롤링 업데이트 형식으로 이루어짐
- SSL 키스토어나 트러스트스토어를 업데이트 하는 것과 같은 작업은 브로커를 재시작할 필요 없이 동적 설정 업데이트로 가능함
- 업데이트 도중에도 클라이언트 애플리케이션이 오래된 리스너를 사용해서 작동할 수 있도록 할 수 잇음
## 암호화
- 암호화는 데이터의 기밀성과 무결성을 보장하기 위해 사용됨
- 물리적 접근 조차도 데이터를 보호하기 위해 제한되야함
- 전체 데이터 흐름이 암호화되는 종단 암호화를 구현하기 위해 커스텀 암호화 제공자를 카프카 클라이언트에 플러그인 형태로 설정함
### 종단 암호화
- 키 관리 시스템에  공유 키를 저장함으로써 프로듀서 쪽은 메시지 암호화, 컨슈머 쪽은 메시지 복호화 과정을 수행함
- 이 방식은 브로커는 암호화 키에 대해 접근할 필요가 없으며, 암호화되지 않은 원본 메시지를 볼 수 없기에 클라우드에서도 안전함
  1. 카프카 프로듀서를 사용해서 메시지를 보냄
  2. 프로듀서가 KMS에 저장된 암호화 키를 사용해서 메시지를 암호화함
  3. 암호화된 메시지가 브로커로 전달됨, 브로커는 암호화된 메시지를 파티션 로그에 저장함
  4. 브로커가 암호화된 메시지를 컨슈머로 보냄
  5. 컨슈머가 KMS에 저장된 암호화 키를 사용해서 메시지를 복호화 함
## 인가
- 사용자가 자원에 대해 어떠한 작동을 수행할 수 있는지를 결정하는 절차임
- 카프카 브로커는 커스터마이즈가 가능한 권한 부여자를 사용해서 접근 제어를 관리함
- AclAuthorizer 권한 부여자를 기본적으로 제공함
### AclAuthorizer
- 이거는 접근 제어 목록을 사용해서 카프카 자원에 대한 접근을 세밀하게 제어해줌
- ACL이라 주로 불림
- ACL은 주키퍼에 저장되는데, 요청을 빠르게 인가하기 위해 모든 브로커의 메모리에 캐시됨
  - p.327 ~ 330 읽어보기
### 인가 기능 커스터마이즈하기
- 카프카의 인가 기능으 커스터마이즈함으로써 추가적인 접근 제한을 설정하거나 역할 기반 접근 제어와 같은 새로운 유형의 접근 제어 기능을 추가할 수 있음
### 고려사항
- ACL을 주키퍼에 저장하기 때문에, 주키퍼에 대한 접근 역시 제한되야함
- 주키퍼쓰기에 안전하지 않으면, ACL을 안전한 외부 DB에 저장하는 커스텀 권한 관리자를 구현할 수 있음
## 감사
- 감사와 디버깅을 목적으로 log4j 로그를 생성하도록 브로커를 설정할 수 있음
### 주키퍼 보안
- 주키퍼는 카프카 클러스터의 가용성을 유지하는 데 필수적인 메타데이터를 저장함
- 카프카뿐만 아니라 주키퍼에도 조치를 취하는 것은 필수적임
- 주키퍼는 케르베로스 인증을 위해 SASL/GSSAPI 메커니즘을 쓰며
- 사용자 이름/비번 위해 SASL/DIGEST-MD5 메커니즘을 사용함
- TLS 지원도 있기에, 상호 인증과 데이터 암호화가 가능함
- 주키퍼의 SASL 기능과 SSL 기능 읽어보기...
